package ru.fit.app.features.progress.list.uiimport androidx.compose.foundation.Canvasimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.fillMaxWidthimport androidx.compose.foundation.layout.heightimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.rememberScrollStateimport androidx.compose.foundation.verticalScrollimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Modifierimport androidx.compose.ui.geometry.Offsetimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.graphics.Pathimport androidx.compose.ui.graphics.drawscope.Strokeimport androidx.compose.ui.platform.LocalDensityimport androidx.compose.ui.text.TextStyleimport androidx.compose.ui.text.drawTextimport androidx.compose.ui.text.rememberTextMeasurerimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport kotlinx.datetime.LocalDateimport ru.fit.app.FitThemeimport ru.fit.app.features.progress.list.presentation.ExerciseProgressimport ru.fit.app.shared.exercise.domain.entity.Exerciseimport kotlin.math.roundToInt@Composablefun Content(	exercise: Exercise,	progress: List<ExerciseProgress>,	modifier: Modifier = Modifier) {	Column(		modifier = modifier			.fillMaxSize()			.verticalScroll(rememberScrollState())			.padding(16.dp)	) {		Text(			text = "Прогресс для ${exercise.name}",			style = MaterialTheme.typography.headlineMedium,			fontSize = 20.sp,			color = FitTheme.colors.fondPrimary,			modifier = Modifier.padding(bottom = 16.dp)		)		if (progress.size < 2) {			Text(				text = "Недостаточно данных для графика",				color = FitTheme.colors.fondSecondary,				modifier = Modifier.padding(16.dp)			)		} else {			LineChartCanvas(				progress = progress.sortedBy { it.date },				modifier = Modifier					.fillMaxWidth()					.height(200.dp)			)		}	}}@Composablefun LineChartCanvas(	progress: List<ExerciseProgress>,	modifier: Modifier = Modifier) {	val density = LocalDensity.current.density.dp	val textMeasurer = rememberTextMeasurer()	Canvas(modifier = modifier) {		val paddingPx = 32.dp.toPx()		val chartWidth = size.width - 2 * paddingPx		val chartHeight = size.height - 2 * paddingPx		if (progress.isEmpty()) return@Canvas		val min1RM = progress.minOf { it.oneRepMax }		val max1RM = progress.maxOf { it.oneRepMax }		val range1RM = max1RM - min1RM		if (range1RM == 0f) return@Canvas		val points = progress.mapIndexed { index, entry ->			val x = paddingPx + (index.toFloat() / (progress.size - 1)) * chartWidth			val y = paddingPx + chartHeight - ((entry.oneRepMax - min1RM) / range1RM) * chartHeight			Offset(x, y)		}		val gridColor = Color(0xFFE0E0E0)		// Рисуем горизонтальные линии сетки		for (k in 0..5) {			val y = paddingPx + (k.toFloat() / 5) * chartHeight			drawLine(				color = gridColor,				start = Offset(paddingPx, y),				end = Offset(paddingPx + chartWidth, y),				strokeWidth = 1f			)		}		// Рисуем вертикальные линии сетки		for (point in points) {			drawLine(				color = gridColor,				start = Offset(point.x, paddingPx),				end = Offset(point.x, paddingPx + chartHeight),				strokeWidth = 1f			)		}		// Рисуем линию прогресса		val path = Path().apply {			moveTo(points.first().x, points.first().y)			points.forEach { lineTo(it.x, it.y) }		}		drawPath(			path = path,			color = Color.Red,			style = Stroke(width = 4f)		)		// Рисуем кружки на каждой точке данных		val circleRadius = 4.dp.toPx()		for (point in points) {			drawCircle(				color = Color.Blue,				radius = circleRadius,				center = point			)		}		// Рисуем оси		drawLine(			color = Color.Gray,			start = Offset(paddingPx, paddingPx),			end = Offset(paddingPx, paddingPx + chartHeight),			strokeWidth = 2f		)		drawLine(			color = Color.Gray,			start = Offset(paddingPx, paddingPx + chartHeight),			end = Offset(paddingPx + chartWidth, paddingPx + chartHeight),			strokeWidth = 2f		)		// Рисуем метки по оси Y		val yLabels = listOf(min1RM, (min1RM + max1RM) / 2, max1RM)		yLabels.forEach { value ->			val textLayoutResult = textMeasurer.measure(				text = "${value.roundToInt()}",				style = TextStyle(					color = Color.Gray,					fontSize = 12.sp				)			)			val y = paddingPx + chartHeight - ((value - min1RM) / range1RM) * chartHeight			val xPos = paddingPx - textLayoutResult.size.width - 4f			val yPos = y - textLayoutResult.size.height / 2f			drawText(				textLayoutResult = textLayoutResult,				topLeft = Offset(xPos, yPos)			)		}		// Рисуем метки по оси X		val xLabelsIndices = listOf(0) + (if (progress.size > 2) listOf(progress.size / 2) else emptyList()) + listOf(progress.size - 1)		xLabelsIndices.forEach { index ->			val dateStr = progress[index].date.toString().substring(5).replace('-', '/')			val textLayoutResult = textMeasurer.measure(				text = dateStr,				style = TextStyle(					color = Color.Gray,					fontSize = 12.sp				)			)			val xPos = paddingPx + (index.toFloat() / (progress.size - 1)) * chartWidth			val yPos = paddingPx + chartHeight + 4f			drawText(				textLayoutResult = textLayoutResult,				topLeft = Offset(xPos - textLayoutResult.size.width / 2f, yPos)			)		}	}}@Composablefun AnalyticsScreenPreview() {	val sampleExercise = Exercise(		id = 1,		name = "Жим лежа",		type = Exercise.ExerciseType.STRENGTH,		targetMuscles = listOf("Грудь", "Трицепс"),		equipment = Exercise.EquipmentType.BARBELL,		difficulty = Exercise.DifficultyLevel.INTERMEDIATE	)	val sampleProgress = listOf(		ExerciseProgress(1, 1, LocalDate(2025, 5, 1), 100f),		ExerciseProgress(2, 1, LocalDate(2025, 5, 2), 105f),		ExerciseProgress(3, 1, LocalDate(2025, 5, 3), 110f),		ExerciseProgress(4, 1, LocalDate(2025, 5, 4), 108f),		ExerciseProgress(5, 1, LocalDate(2025, 5, 5), 112f)	)	FitTheme {		Content(			exercise = sampleExercise,			progress = sampleProgress,			modifier = Modifier.fillMaxSize()		)	}}