package ru.fit.app.features.exercise.presentationimport androidx.activity.OnBackPressedDispatcherimport androidx.lifecycle.ViewModelStoreimport app.cash.turbine.testimport com.arkivanov.decompose.ComponentContextimport com.arkivanov.decompose.ComponentContextFactoryimport com.arkivanov.essenty.backhandler.BackHandlerimport com.arkivanov.essenty.instancekeeper.InstanceKeeperimport com.arkivanov.essenty.lifecycle.LifecycleRegistryimport com.arkivanov.essenty.statekeeper.StateKeeperimport io.mockk.coEveryimport io.mockk.coVerifyimport io.mockk.mockkimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.ExperimentalCoroutinesApiimport kotlinx.coroutines.test.StandardTestDispatcherimport kotlinx.coroutines.test.runTestimport kotlinx.coroutines.test.setMainimport kotlinx.datetime.Instantimport ru.fit.app.shared.training.domain.entity.Trainingimport ru.fit.app.shared.training.domain.usecase.GetTrainingsUseCaseimport kotlin.test.BeforeTestimport kotlin.test.Testimport kotlin.test.assertEquals@OptIn(ExperimentalCoroutinesApi::class)class TrainingComponentTest {	private lateinit var getTrainingsUseCase: GetTrainingsUseCase	private lateinit var mainNavigation: MainNavigation	private val testDispatcher = StandardTestDispatcher()	private val componentContext: ComponentContext = createTestComponentContext()	@BeforeTest	fun setup() {		Dispatchers.setMain(testDispatcher)		getTrainingsUseCase = mockk()		mainNavigation = mockk(relaxed = true)	}	private val trainings = listOf(Training(1, "Training 1", Instant.DISTANT_PAST, emptyList()))	@Test	fun `loadTrainings invoke state to initial`() = runTest {		val component = MainComponent(			componentContext = componentContext,			getTrainingsUseCase = getTrainingsUseCase,			mainNavigation = mainNavigation		)		val state = component.screenState.value		coEvery { getTrainingsUseCase() } returns trainings		component.loadContent()		assertEquals(state, State.Initial)	}	@Test	fun `loadContent sets screenState to Loading`() = runTest {		val component = MainComponent(			componentContext = componentContext,			getTrainingsUseCase = getTrainingsUseCase,			mainNavigation = mainNavigation		)		coEvery { getTrainingsUseCase() } returns trainings		component.screenState.test {			assertEquals(State.Initial, awaitItem())			component.loadContent()			assertEquals(State.Loading, awaitItem())			assertEquals(State.Content(trainings), awaitItem())			cancelAndIgnoreRemainingEvents()		}	}	@Test	fun `loadTrainings get trainings use case `() = runTest {		val component = MainComponent(			componentContext = componentContext,			getTrainingsUseCase = getTrainingsUseCase,			mainNavigation = mainNavigation		)		coEvery { getTrainingsUseCase() } returns trainings		component.loadContent()		testScheduler.runCurrent()		coVerify { getTrainingsUseCase() }	}}fun createTestComponentContext(): ComponentContext =	object : ComponentContext {		override val backHandler: BackHandler			get() = BackHandler(OnBackPressedDispatcher())		override val componentContextFactory: ComponentContextFactory<ComponentContext>			get() = TODO("Not yet implemented")		override val instanceKeeper: InstanceKeeper			get() = InstanceKeeper(ViewModelStore())		override val lifecycle = LifecycleRegistry()		override val stateKeeper: StateKeeper			get() = TODO("Not yet implemented")	}